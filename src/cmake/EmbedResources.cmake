# EmbedResources.cmake

function(embed_resources TARGET)
    # Get the list of resource files from additional arguments
    set(RESOURCE_FILES ${ARGN})

    # Create a directory for generated object files
    set(RESOURCE_OBJ_DIR "${CMAKE_CURRENT_BINARY_DIR}/${TARGET}_resources_obj")
    file(MAKE_DIRECTORY ${RESOURCE_OBJ_DIR})

    foreach(RES_FILE IN LISTS RESOURCE_FILES)
        # Generate a safe symbol name by replacing non-alphanumeric characters
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" RES_NAME ${RES_FILE})
        set(OBJ_FILE "${RESOURCE_OBJ_DIR}/${RES_NAME}.o")

        # Get the base name for the default symbol generated by objcopy
        get_filename_component(BASE_NAME ${RES_FILE} NAME)
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" BASE_RES_NAME ${BASE_NAME})

        # Handle absolute and relative paths
        if(IS_ABSOLUTE ${RES_FILE})
            set(RES_PATH ${RES_FILE})
            # message(STATUS "absolute ${RES_PATH}")
        else()
            set(RES_PATH "${CMAKE_CURRENT_SOURCE_DIR}/${RES_FILE}")
            # set(RES_PATH ${RES_FILE})
        endif()
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" RES_PATH_SYMBOL ${RES_PATH})
        # message(STATUS "\nres path ${RES_PATH}")
        # message(STATUS "res file ${RES_FILE}")
        # message(STATUS "obj file ${OBJ_FILE}")
        # message(STATUS "base res name '${BASE_RES_NAME}'")
        # message(STATUS "res name '${RES_NAME}'")
        # message(STATUS "res path symbol '${RES_PATH_SYMBOL}'")

        # Convert binary file to object file using objcopy and rename symbols
        # message(STATUS "--redefine-sym _binary_${BASE_RES_NAME}_start=_binary_${RES_NAME}_start")
        add_custom_command(
            OUTPUT ${OBJ_FILE}
            COMMAND objcopy --input-target=binary --output-target=elf64-x86-64
                    "${RES_PATH}" ${OBJ_FILE}
            COMMAND objcopy 
                    --redefine-sym _binary_${RES_PATH_SYMBOL}_start=_binary_${RES_NAME}_start
                    --redefine-sym _binary_${RES_PATH_SYMBOL}_size=_binary_${RES_NAME}_size
                    --redefine-sym _binary_${RES_PATH_SYMBOL}_end=_binary_${RES_NAME}_end
                    ${OBJ_FILE}
            COMMAND objcopy --add-section .note.GNU-stack=/dev/null --set-section-flags .note.GNU-stack=readonly ${OBJ_FILE} ${OBJ_FILE}
            DEPENDS ${RES_FILE}
            COMMENT "Embedding ${RES_FILE} into object file and renaming symbols"
        )
        list(APPEND RESOURCE_OBJECTS ${OBJ_FILE})
    endforeach()

    # Generate target-specific resources.h
    set(RESOURCE_HEADER "${CMAKE_CURRENT_BINARY_DIR}/${TARGET}_resources.h")
    file(WRITE ${RESOURCE_HEADER} "#ifndef ${TARGET}_RESOURCES_H\n#define ${TARGET}_RESOURCES_H\n\n")
    file(APPEND ${RESOURCE_HEADER} "#include <string>\n#include <cstdint>\n\n")
    file(APPEND ${RESOURCE_HEADER} "struct Resource {\n    const unsigned char* start;\n    const size_t size;\n    const unsigned char* end;\n};\n\n")
    file(APPEND ${RESOURCE_HEADER} "Resource get_resource(const std::string& name);\n\n")
    file(APPEND ${RESOURCE_HEADER} "#endif // ${TARGET}_RESOURCES_H\n")

    # Generate target-specific resources.cpp
    set(RESOURCE_CPP "${CMAKE_CURRENT_BINARY_DIR}/${TARGET}_resources.cpp")
    file(WRITE ${RESOURCE_CPP} "#include \"${TARGET}_resources.h\"\n#include <unordered_map>\n#include <string>\n\n")
    file(APPEND ${RESOURCE_CPP} "extern \"C\" {\n")
    foreach(RES_FILE IN LISTS RESOURCE_FILES)
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" RES_NAME ${RES_FILE})
        file(APPEND ${RESOURCE_CPP} "    extern const unsigned char _binary_${RES_NAME}_start[];\n")
        file(APPEND ${RESOURCE_CPP} "    extern const unsigned char _binary_${RES_NAME}_end[];\n")
        file(APPEND ${RESOURCE_CPP} "    const size_t _binary_${RES_NAME}_size = _binary_${RES_NAME}_end - _binary_${RES_NAME}_start;\n")
    endforeach()
    file(APPEND ${RESOURCE_CPP} "}\n\n")
    file(APPEND ${RESOURCE_CPP} "Resource get_resource(const std::string& name) {\n")
    file(APPEND ${RESOURCE_CPP} "    static const std::unordered_map<std::string, Resource> resources = {\n")
    foreach(RES_FILE IN LISTS RESOURCE_FILES)
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" RES_NAME ${RES_FILE})
        file(APPEND ${RESOURCE_CPP} "        {\"${RES_FILE}\", {_binary_${RES_NAME}_start, _binary_${RES_NAME}_size, _binary_${RES_NAME}_end}},\n")
    endforeach()
    file(APPEND ${RESOURCE_CPP} "    };\n")
    file(APPEND ${RESOURCE_CPP} "    auto it = resources.find(name);\n")
    file(APPEND ${RESOURCE_CPP} "    if (it != resources.end()) {\n")
    file(APPEND ${RESOURCE_CPP} "        return it->second;\n")
    file(APPEND ${RESOURCE_CPP} "    }\n")
    file(APPEND ${RESOURCE_CPP} "    return {nullptr, 0, nullptr};\n")
    file(APPEND ${RESOURCE_CPP} "}\n")

    # Add generated files to the target
    target_sources(${TARGET} PRIVATE ${RESOURCE_CPP} ${RESOURCE_OBJECTS})
    target_include_directories(${TARGET} PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
    # message(STATUS "current build dir: ${CMAKE_CURRENT_BINARY_DIR}")

    # Define the RESOURCES_HEADER macro for this target
    target_compile_definitions(${TARGET} PRIVATE RESOURCES_HEADER="${TARGET}_resources.h")

    # Ensure the generated files are included in the target's build
    # target_sources(${TARGET} PRIVATE "${CMAKE_CURRENT_BINARY_DIR}/${TARGET}_resources.cpp")
    # target_include_directories(${TARGET} PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
endfunction()
